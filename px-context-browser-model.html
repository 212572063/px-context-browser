<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../iron-ajax/iron-ajax.html"/>
<link rel="import" href="px-context-browser-behaviors.html"/>
<style>
  /* this is a non-visual element */
  :host {
    display: none;
  }
</style>

<dom-module id="px-context-browser-model">
  <template>
    <iron-ajax
      url="[[_jsonUrl]]"
      handle-as="json"
      debounce-duration="300"
      last-response="{{_lastResponse}}"
      auto></iron-ajax>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'px-context-browser-model',
    behaviors: [PxContextBrowserBehaviors],
    properties: {
      context : {
        value: function() {return {};},
        type: Object,
        notify: true
      },
      apiUrl: {
        type: String
      },
      selectedItemUri: {
        type: String,
        observer: '_selectedItemUriChanged'
      },
      _jsonUrl: {
        type: String,
        computed: '_computeJsonUrl(apiUrl, selectedItemUri)'
      },
      _lastResponse: {
        type: Object,
        observer: '_lastResponseChanged'
      }
    },

    _computeJsonUrl: function() {
      return this.apiUrl + this.selectedItemUri;
    },

    _setLocalUpdatedAt: function() {
      this.set('context.localUpdatedAt', (new Date).getTime());
    },

    /* fires on change to json response vale in _lastResponse */
    _lastResponseChanged: function(newValue, oldValue) {
      // Upon init, context object should be empty {}
      if(_.isEmpty(this.context)) {
        this.set('context', newValue);
        this._setLocalUpdatedAt();
      } else {
        // After init, context will have data to be preserved
        // So we must merge new data into existing context object using lodash merge
        try {
          var destinationNode = this._findNodeByUri(newValue.uri);
          _.merge(destinationNode, newValue);
          this._setLocalUpdatedAt();
        } catch(e) {
          console.log(e);
        }
      }
    },

    /* recursive find node by arbitrary key / value pair on nested objects */
    _findNode: function(nodes, key, value) {
      var _this = this, node, childrenKey, childrenExist, i = 0, len = nodes.length;
      for(i;i<len;i++) {
        node = nodes[i];
        if(node[key] && _.isEqual(node[key], value)) { return node };
        childrenKey = _this.fieldKeys['children'];
        childrenExist = (node[childrenKey] && node[childrenKey].length > 0) ? true : false;
        return childrenExist ? _this._findNode(node[childrenKey], key, value) : null;
      }
    },

    _findNodeByUri: function(uri) {
      return this._findNode([this.context], 'uri', uri);
    },

    _findNodeById: function(id) {
      return this._findNode([this.context], 'id', id);
    },

    _selectedItemUriChanged: function() {
      if(typeof this.selectedItemUri !== 'undefined') {
        this._markSelected(this.selectedItemUri);
      }
    },

    _markSelected: function(uri) {
      var node = this._findNodeByUri(uri);
      if(node) {
        node.selected = true;
        this._setLocalUpdatedAt();
      }
    }

  });
</script>
