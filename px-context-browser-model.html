<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../iron-ajax/iron-ajax.html"/>
<link rel="import" href="px-context-browser-behaviors.html"/>
<style>
  /* this is a non-visual element */
  :host {
    display: none;
  }
</style>

<dom-module id="px-context-browser-model">
  <template>
    <iron-ajax
      url="[[_jsonUrl]]"
      handle-as="json"
      debounce-duration="300"
      last-response="{{_lastResponse}}"
      auto></iron-ajax>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'px-context-browser-model',
    behaviors: [PxContextBrowserBehaviors],
    properties: {
      context : {
        value: function() {return {};},
        type: Object,
        notify: true
      },
      apiUrl: {
        type: String
      },
      selectedItemUri: {
        type: String,
        observer: '_selectedItemUriChanged'
      },
      _jsonUrl: {
        type: String,
        computed: '_computeJsonUrl(apiUrl, selectedItemUri)'
      },
      _lastResponse: {
        type: Object,
        observer: '_lastResponseChanged'
      }
    },

    _computeJsonUrl: function() {
      return this.apiUrl + this.selectedItemUri;
    },

    _setLocalUpdatedAt: function() {
      this.set('context.localUpdatedAt', (new Date).getTime());
    },

    /* fires on change to json response vale in _lastResponse */
    _lastResponseChanged: function(newValue, oldValue) {
      // Upon init, context object should be empty {}
      if(_.isEmpty(this.context)) {
        this.set('context', newValue);
        this._setLocalUpdatedAt();
      } else {
        // After init, context will have data to be preserved
        // So we must merge new data into existing context object using lodash merge
        try {
          var destinationNode = this._findNodeByUri(newValue.uri);
          _.merge(destinationNode, newValue);
          this._setLocalUpdatedAt();
        } catch(e) {
          console.log(e);
        }
      }
    },

    /* recursive find node by arbitrary key / value pair on nested objects */
    _findNode: function(nodes, key, value) {
      var _this = this, found = null, childrenKey = _this.fieldKeys['children'];
      var foundNodes = _.filter(nodes, function(n) { return n[key] === value; });
      if(foundNodes.length) {
        return foundNodes[0];
      } else {
        var haveChildren = _.filter(nodes, function(n) {
          return typeof n[childrenKey] !== 'undefined' && n[childrenKey].length;
        });
        for(i=0;i<haveChildren.length;i++) {
          var found = _this._findNode(haveChildren[i][childrenKey], key, value);
          if(found !== null) {
            break;
          }
        }
        if(found) {
          return found;
        } else {
          return null;
        }
      }
    },

    _findNodeByUri: function(uri) {
      return this._findNode([this.context], 'uri', uri);
    },

    _findNodeById: function(id) {
      return this._findNode([this.context], 'id', id);
    },

    _findNodePeers: function(nodes, peer) {
      var _this = this, node, childrenExist, i = 0, len = nodes.length;
      var childrenKey = _this.fieldKeys['children'];
      for(i;i<len;i++) {
        node = nodes[i];
        if(_.isEqual(node, peer)) {
          return _.reject(nodes, function(n) { return _.isEqual(n.uri, peer.uri); });
        }
      }
      var haveChildren = _.filter(nodes, function(n) {
        return typeof n[childrenKey] !== 'undefined' && n[childrenKey].length;
      });
      for(i=0;i<haveChildren.length;i++) {
        var found = _this._findNodePeers(haveChildren[i][childrenKey], peer);
        if(found !== null) {
          break;
        }
      }
      if(found) {
        return found;
      } else {
        return null;
      }
    },

    _selectedItemUriChanged: function() {
      if(typeof this.selectedItemUri !== 'undefined') {
        this._markSelected(this.selectedItemUri);
      }
    },

    _markSelected: function(uri) {
      var node = this._findNodeByUri(uri);
      if(node) {
        node.selected = true;
        var peers = this._findNodePeers([this.context], node);
        _.each(peers, function(p) {
          p.selected = false;
        });
        console.log(peers);
        this._setLocalUpdatedAt();
      }

    }

  });
</script>
