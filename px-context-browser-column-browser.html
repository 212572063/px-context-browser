<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="px-context-browser-column.html"/>
<link rel="import" href="px-context-browser-behaviors.html"/>

<dom-module id="px-context-browser-column-browser">
  <link rel="import" type="css" href="css/px-context-browser.css" />
  <script src="../lodash/lodash.js"></script>
  <template>
    <div class="flex flex--col column-browser">
      <px-spinner id="spinner" finished></px-spinner>
      <div class="flex">
        <template is="dom-repeat" id="levels" items="[[_columns]]">
          <px-context-browser-column
            column-data="[[item]]"
            field-keys="[[fieldKeys]]"
            context="[[context]]"></px-context-browser-column>
        </template>
      </div>
      <div class="ruler">
      </div>
      <div class="overlay"></div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'px-context-browser-column-browser',
    behaviors: [PxContextBrowserBehaviors],
    properties: {
      _columns: {
        type: Array,
        value: function() { return []; }
      }
    },

    observers: [
      '_contextChanged(fieldKeys, _columns, context, context.localUpdatedAt)'
    ],

    _contextChanged: function() {
      if(!_.isEmpty(this.context)) {
        this._setColumns();
      } else {
        this.columns = [];
      }
    },

    // remove all columns so that they can be reset
    _popAllColumns: function() {
      _.forEach(this._columns, this._popColumn.bind(this));
    },

    // pop one single columnItem off this._columnItems
    _popColumn: function() {
      this.pop('_columns');
    },

    _addColumn(node, index) {
      var childrenKey = this.fieldKeys['children'];
      var children = node[childrenKey] || [];
      var i, len = children.length;
      if(len > 0) {
        if(!_.isEqual(this._columns[index], { children })) {
          this.push('_columns', { children });
        }
        for(i=0;i<len;i++) {
          var childNode = children[i];
          if(typeof childNode.selected !== 'undefined' && childNode.selected === true) {
            var grandChildren = childNode[childrenKey];
            if(typeof grandChildren !== 'undefined' && grandChildren.length > 0) {
              this._addColumn(childNode, index++);
            }
          }
        }
      }
    },

    _setColumns: function() {
      this._addColumn(this.context, 0);
      /*
      if(_.isEmpty(this._columns)) {
        // add the first column
        this.push('_columns', { children });
      } else {
        console.log('update existing columns')
        // update existing columns
        this.set('_columns.0', { children });
        _.each(children, function(child) {
          if(child.selected) {
            console.log('child selected:', child);
          }
        });
        // TODO: Recursively add more columns as children have many children...
        }
      */
    },

    showOverlay: function() {
      this.$$('.overlay').style.display = 'block';
    },

    hideOverlay: function() {
      this.$$('.overlay').style.display = 'none';
    },

    showSpinner: function() {
      this.$.spinner.set('finished', false);
    },

    hideSpinner: function() {
      this.$.spinner.set('finished', true);
    }

  });
</script>
